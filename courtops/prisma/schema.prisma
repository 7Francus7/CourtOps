generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Club {
  id                 String         @id @default(uuid())
  name               String
  slug               String         @unique
  logoUrl            String?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt
  timezone           String         @default("America/Argentina/Buenos_Aires")
  currency           String         @default("ARS")
  openTime           String         @default("14:00")
  closeTime          String         @default("00:30")
  slotDuration       Int            @default(90)
  cancelHours        Int            @default(6)
  plan               String         @default("BASIC")
  subscriptionStatus String         @default("TRIAL")
  nextBillingDate    DateTime?
  maxCourts          Int            @default(2)
  maxUsers           Int            @default(3)
  hasKiosco          Boolean        @default(false)
  hasOnlinePayments  Boolean        @default(false)
  hasAdvancedReports Boolean        @default(false)
  hasCustomDomain    Boolean        @default(false)
  bookings           Booking[]
  mpAlias            String?
  mpCvu              String?
  cashRegisters      CashRegister[]
  clients            Client[]
  courts             Court[]
  priceRules         PriceRule[]
  products           Product[]
  users              User[]
  auditLogs          AuditLog[]
  waitingList        WaitingList[]
  membershipPlans    MembershipPlan[]

  @@map("Club")
}

model User {
  id        String     @id @default(uuid())
  email     String     @unique
  password  String
  name      String
  role      String
  clubId    String?
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  club      Club?      @relation(fields: [clubId], references: [id], onDelete: Cascade)
  auditLogs AuditLog[]

  @@map("User")
}

model Court {
  id          Int           @id @default(autoincrement())
  clubId      String
  name        String
  surface     String?
  isIndoor    Boolean       @default(false)
  isActive    Boolean       @default(true)
  sortOrder   Int           @default(0)
  bookings    Booking[]
  club        Club          @relation(fields: [clubId], references: [id], onDelete: Cascade)
  waitingList WaitingList[]

  @@map("Court")
}

model Client {
  id           Int           @id @default(autoincrement())
  clubId       String
  name         String
  phone        String
  notes        String?
  createdAt    DateTime      @default(now())
  email        String?
  bookings     Booking[]
  club         Club          @relation(fields: [clubId], references: [id], onDelete: Cascade)
  transactions Transaction[]
  waitingList  WaitingList[]

  // Membership (Legacy & Advanced)
  membershipStatus    String    @default("NONE") // NONE, ACTIVE
  membershipExpiresAt DateTime?
  memberships         Membership[]

  @@unique([clubId, phone])
  @@index([clubId, name])
  @@map("Client")
}

model PriceRule {
  id         Int       @id @default(autoincrement())
  clubId     String
  name       String?
  priority   Int       @default(0)
  startDate  DateTime?
  endDate    DateTime?
  daysOfWeek String?
  startTime  String
  endTime    String
  price      Float
  memberPrice Float? // Optional override for members
  club       Club      @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@map("PriceRule")
}

model Booking {
  id            Int      @id @default(autoincrement())
  clubId        String
  courtId       Int
  clientId      Int?
  publicToken   String?
  recurringId   String?
  startTime     DateTime
  endTime       DateTime
  price         Float
  status        String
  paymentStatus String
  paymentMethod String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  client        Client?  @relation(fields: [clientId], references: [id])
  court         Court    @relation(fields: [courtId], references: [id])
  club          Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)

  guestName     String?
  guestPhone    String?

  items        BookingItem[]
  transactions Transaction[]
  players      BookingPlayer[]

  @@index([clubId, startTime])
  @@index([clubId, status])
  @@index([clubId, clientId])
  @@map("Booking")
}

model BookingItem {
  id        Int   @id @default(autoincrement())
  bookingId Int
  productId Int?
  quantity  Int   @default(1)
  unitPrice Float @default(0)

  booking Booking  @relation(fields: [bookingId], references: [id], onDelete: Cascade)
  product Product? @relation(fields: [productId], references: [id])

  playerName String? // Optional: assign item to a specific player

  @@map("BookingItem")
}

model Product {
  id           Int               @id @default(autoincrement())
  clubId       String
  name         String
  category     String
  cost         Float
  price        Float
  memberPrice  Float?
  stock        Int
  minStock     Int               @default(5)
  imageUrl     String?
  isActive     Boolean           @default(true)
  club         Club              @relation(fields: [clubId], references: [id], onDelete: Cascade)
  transactions TransactionItem[]
  bookingItems BookingItem[]

  @@map("Product")
}

model BookingPlayer {
  id            Int     @id @default(autoincrement())
  bookingId     Int
  name          String
  amount        Float   @default(0)
  isPaid        Boolean @default(false)
  paymentMethod String?

  booking Booking @relation(fields: [bookingId], references: [id], onDelete: Cascade)

  @@map("BookingPlayer")
}

model CashRegister {
  id              Int           @id @default(autoincrement())
  clubId          String
  date            DateTime      @default(now())
  openedAt        DateTime      @default(now())
  closedAt        DateTime?
  startAmount     Float         @default(0)
  endAmountCash   Float?
  endAmountTransf Float?
  status          String
  club            Club          @relation(fields: [clubId], references: [id], onDelete: Cascade)
  transactions    Transaction[]

  @@index([clubId, date])
  @@map("CashRegister")
}

model Transaction {
  id             Int               @id @default(autoincrement())
  cashRegisterId Int
  clientId       Int?
  type           String
  category       String
  amount         Float
  method         String
  description    String?
  createdAt      DateTime          @default(now())
  bookingId      Int?
  booking        Booking?          @relation(fields: [bookingId], references: [id])
  client         Client?           @relation(fields: [clientId], references: [id])
  cashRegister   CashRegister      @relation(fields: [cashRegisterId], references: [id], onDelete: Cascade)
  items          TransactionItem[]

  @@map("Transaction")
}

model TransactionItem {
  id            Int         @id @default(autoincrement())
  transactionId Int
  productId     Int?
  quantity      Int
  unitPrice     Float
  subtotal      Float
  product       Product?    @relation(fields: [productId], references: [id])
  transaction   Transaction @relation(fields: [transactionId], references: [id], onDelete: Cascade)

  @@map("TransactionItem")
}

model AuditLog {
  id        String   @id @default(uuid())
  clubId    String
  userId    String?
  action    String // CREATE, UPDATE, DELETE, LOGIN
  entity    String // BOOKING, CLIENT, SETTINGS
  entityId  String?
  details   String? // JSON string con detalles del cambio
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  club Club  @relation(fields: [clubId], references: [id], onDelete: Cascade)
  user User? @relation(fields: [userId], references: [id])

  @@index([clubId, createdAt])
  @@index([clubId, entity, entityId])
  @@map("AuditLog")
}

model WaitingList {
  id        Int       @id @default(autoincrement())
  clubId    String
  date      DateTime // The specific day they are waiting for
  startTime DateTime? // Optional: preferred start time
  endTime   DateTime? // Optional: preferred end time
  courtId   Int? // Optional: preferred court

  clientId Int?
  name     String // Fallback if no client ID
  phone    String // Fallback if no client ID
  notes    String?

  status    String   @default("PENDING") // PENDING, FULFILLED, CANCELED
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  club   Club    @relation(fields: [clubId], references: [id], onDelete: Cascade)
  client Client? @relation(fields: [clientId], references: [id])
  court  Court?  @relation(fields: [courtId], references: [id])

  @@index([clubId, date])
  @@map("WaitingList")
}

model MembershipPlan {
  id          String   @id @default(uuid())
  clubId      String
  name        String
  description String?
  price       Float    // Precio del plan en sí
  durationDays Int     @default(30) // Duración en días
  
  // Beneficios
  discountPercent Float @default(0) // % de descuento en turnos
  discountFixed   Float @default(0) // Monto fijo de descuento
  
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  club        Club     @relation(fields: [clubId], references: [id], onDelete: Cascade)
  memberships Membership[]

  @@map("MembershipPlan")
}

model Membership {
  id          String   @id @default(uuid())
  clientId    Int
  planId      String
  
  startDate   DateTime @default(now())
  endDate     DateTime
  
  pricePaid   Float
  status      String   @default("ACTIVE") // ACTIVE, EXPIRED, CANCELLED
  
  client      Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)
  plan        MembershipPlan @relation(fields: [planId], references: [id])
  
  createdAt   DateTime @default(now())

  @@index([clientId, status])
  @@map("Membership")
}
